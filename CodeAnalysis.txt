Ns2 code analysis 

drr.cc


PacketDRR class
This is basically a queue for each flow.
It keeps track of
* Number of packets in flow
* Total bytes to find max flow
* Source address to detect collisions(?)
* Deficit counter
* Turn variable, boolean to check if itâ€™s current packets turn
* There is an activate and idle function - need to clearly understand what it does, most probably activate for dispatch.
* It has pointers to the next and previous PacketDRR object. All the queues(buckets) are arranged like a linked list.


DRR class
The main class which implements the functionalities.
* Number of flows allowed
* Number of active flows
* All variables are listed with proper usage in comments
* Has a hash function to choose the flow(PacketDRR) into which the packet is to be inserted
* GetMaxFlow function to choose the flow(PacketDRR) with max bytes so that you can drop a packet from it
* Enque and deque functions
* Line 167, 168 //what do they do
         hdr_cmn *ch= hdr_cmn::access(pkt);
 hdr_ip *iph = hdr_ip::access(pkt);
* Ch is used to get the size of the pkt 
* Look at the equivalent of hdr_cmn




Ns3 PFIFO code analysis
/ns-3-dev/src/traffic-control/pfifo-fast-queue-disc.cc


PfifoFastQueueDisc class
The main class which handles functionality
* Has a constructor (does some logging)
* Destructor
* doEnqueue method
        - call GetNPackets method and check if greater than limit, if so Drop packet
        - set priority
        - obtain required queue based on priority and enqueue packet there
* DoDequeue method - dequeue packet from appropriate internal queue
* The DoEnqueue and DoDequeue functions provide the interface to the blackbox that is the DRR queue. Internally these functions identify the internal queue which is to be operated upon and modify it accordingly
* DoPeek method - 
* CheckConfig Method
* GetNInternalQueues gives us number of internal queues
* GetInternalQueue (i) gives us the ith internal queue and functions like enqueue, dequeue and peek are already defined for these


linux/net/sched/sch_sfq.c
* static inline struct sfq_head *sfq_dep_head
* Sfq_hash
* Sfq_classify
* Sfq_link
* Sfq_unlink
* Sfq_dec
* Sfq_inc
* Slot_queue_init
* Slot_queue_add
* Sfq_drop
* Sfq_prob_mark
* Sfq_headdrop
* Sfq_enqueue
* Sfq_dequeue
* Sfq_reset
* Sfq_rehash
* Sfq_perturbation
* Sfq_change
* Sfq_free
* Sfq_destroy
* Sfq_init
* Sfq_dump
* Sfq_leaf
* Sfq_find
* Sfq_bind
* Sfq_unbind
* Sfq_walk


Ns3 QueueDisc code analysis
/ns-3-dev/src/traffic-control/queue-disc.cc
/ns-3-dev/src/traffic-control/queue-disc.h


QueueDiscClass Class - A base class for pointing to a single queueDisc that is attached to that particular class (Class - Differentiating so as to give different treatment for different types of packets).
* One data member - Pointer to a queueDisc
* Functions to deal with the queueDisc like getting and setting the queueDisc, getting the typeID of that particular class


QueueDisc Class - The abstract class that is used for implementing operations common to all queueing disciplines. 
* DoEnqueue, DoDequeue (According to the algorithm, performs the operation after choosing the internal queue to enqueue/dequeue), DoPeek (Gives copy of next element to be dequeued), checkConfig, InitialiseParams (Check the params before first element is enqueued) - All are virtual functions to be implemented in the derived class (i.e, the DRR class).
* 3 main data members - Classes, Filters (That can be applied to packets to determine which class or queue the packet belongs to), Queues (Stores the actual packets to be transacted. Uses the C++ queue template for packets. I.e, QueueDiscItem) - Stored as vector of pointers
* Functions dealing with adding, getting all the pointers stored in the 3 data members are implemented in this abstract class
* Trivial functions for attributes such as getting number of packets, bytes, number of packets enqueued, dequeued, dropped, dropped before enqueued, dropped after dequeued etc (i.e, the statistics of the packet transactions during the time that the queue was active) are implemented.
* Functions for initiating and terminating the running of the queueDisc in context are also implemented
* Functions for associating the Queue Discipline with a network device interface
* Packets = QueueDiscItem defined in queue-item.h. Has all the trivial functions to deal with a packet